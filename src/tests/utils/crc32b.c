/*
 * Astra Unit Tests
 * http://cesbo.com/astra
 *
 * Copyright (C) 2016-2017, Artem Kharitonov <artem@3phase.pw>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "../libastra.h"
#include <astra/utils/crc32b.h>

/* PSI tables */
static
const uint8_t test_tables[][96] =
{
    {
        0x00, 0xb0, 0x5d, 0x00, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x10,
        0x00, 0x01, 0xe7, 0xfb, 0x00, 0x09, 0xe7, 0xfa, 0x00, 0x17, 0xe7, 0xf9,
        0x00, 0x18, 0xe7, 0xfc, 0x00, 0x02, 0xe8, 0x02, 0x00, 0x03, 0xe8, 0x04,
        0x00, 0x04, 0xe8, 0x06, 0x00, 0x06, 0xe8, 0x0a, 0x00, 0x07, 0xe8, 0x0c,
        0x00, 0x08, 0xe8, 0x0e, 0x00, 0x0a, 0xe8, 0x12, 0x00, 0x0b, 0xe8, 0x14,
        0x00, 0x0c, 0xe8, 0x16, 0x00, 0x0d, 0xe8, 0x18, 0x00, 0x0e, 0xe8, 0x1a,
        0x00, 0x0f, 0xe8, 0x1c, 0x00, 0x10, 0xe8, 0x1e, 0x00, 0x11, 0xe8, 0x20,
        0x00, 0x12, 0xe8, 0x22, 0x00, 0x13, 0xe7, 0xf8, 0x00, 0xaa, 0xe5, 0xae,
    },
    {
        0x01, 0xb0, 0x09, 0xff, 0xff, 0xe1, 0x00, 0x00, 0xed, 0x78, 0x32, 0xa2,
    },
    {
        0x02, 0xb0, 0x15, 0x00, 0x10, 0xdf, 0x00, 0x00, 0xf0, 0xa4, 0xf0, 0x00,
        0x03, 0xf0, 0xa4, 0xf0, 0x03, 0x52, 0x01, 0x01, 0x1b, 0x99, 0x92, 0xc0,
    },
    {
        0x02, 0xb0, 0x15, 0x00, 0x0f, 0xdf, 0x00, 0x00, 0xf0, 0x86, 0xf0, 0x00,
        0x03, 0xf0, 0x86, 0xf0, 0x03, 0x52, 0x01, 0x01, 0xb6, 0x5e, 0x99, 0x80,
    },
    {
        0x02, 0xb0, 0x15, 0x00, 0x0e, 0xdf, 0x00, 0x00, 0xf0, 0x7c, 0xf0, 0x00,
        0x03, 0xf0, 0x7c, 0xf0, 0x03, 0x52, 0x01, 0x01, 0x9a, 0x20, 0x5f, 0xd2,
    },
    {
        0x02, 0xb0, 0x15, 0x00, 0x0d, 0xdf, 0x00, 0x00, 0xf0, 0x48, 0xf0, 0x00,
        0x03, 0xf0, 0x48, 0xf0, 0x03, 0x52, 0x01, 0x01, 0x50, 0xe3, 0x89, 0xa3,
    },
    {
        0x02, 0xb0, 0x15, 0x00, 0x0c, 0xdf, 0x00, 0x00, 0xf0, 0x68, 0xf0, 0x00,
        0x03, 0xf0, 0x68, 0xf0, 0x03, 0x52, 0x01, 0x01, 0x56, 0xd8, 0x24, 0x4d,
    },
    {
        0x02, 0xb0, 0x15, 0x00, 0x0b, 0xdf, 0x00, 0x00, 0xf0, 0x0f, 0xf0, 0x00,
        0x03, 0xf0, 0x0f, 0xf0, 0x03, 0x52, 0x01, 0x01, 0x46, 0x57, 0xa0, 0x1b,
    },
    {
        0x02, 0xb0, 0x15, 0x00, 0x0a, 0xdf, 0x00, 0x00, 0xf0, 0x54, 0xf0, 0x00,
        0x03, 0xf0, 0x54, 0xf0, 0x03, 0x52, 0x01, 0x01, 0x07, 0x11, 0xb5, 0x5b,
    },
    {
        0x02, 0xb0, 0x15, 0x00, 0x09, 0xdf, 0x00, 0x00, 0xf0, 0x00, 0xf0, 0x00,
        0x03, 0xf0, 0x00, 0xf0, 0x03, 0x52, 0x01, 0x01, 0xb7, 0x46, 0x54, 0x56,
    },
    {
        0x02, 0xb0, 0x15, 0x00, 0x08, 0xdf, 0x00, 0x00, 0xf0, 0x2f, 0xf0, 0x00,
        0x03, 0xf0, 0x2f, 0xf0, 0x03, 0x52, 0x01, 0x01, 0x1f, 0x03, 0x73, 0x81,
    },
    {
        0x02, 0xb0, 0x15, 0x00, 0x07, 0xdf, 0x00, 0x00, 0xf0, 0x01, 0xf0, 0x00,
        0x03, 0xf0, 0x01, 0xf0, 0x03, 0x52, 0x01, 0x01, 0xcd, 0x0f, 0xb8, 0x3b,
    },
    {
        0x02, 0xb0, 0x15, 0x00, 0x06, 0xdf, 0x00, 0x00, 0xf0, 0x2c, 0xf0, 0x00,
        0x03, 0xf0, 0x2c, 0xf0, 0x03, 0x52, 0x01, 0x01, 0xa4, 0x82, 0x97, 0x77,
    },
    {
        0x02, 0xb0, 0x15, 0x00, 0x04, 0xdf, 0x00, 0x00, 0xef, 0xfd, 0xf0, 0x00,
        0x03, 0xef, 0xfd, 0xf0, 0x03, 0x52, 0x01, 0x01, 0xd2, 0xb0, 0x0c, 0xaf,
    },
    {
        0x02, 0xb0, 0x15, 0x00, 0x03, 0xdf, 0x00, 0x00, 0xf0, 0x0e, 0xf0, 0x00,
        0x03, 0xf0, 0x0e, 0xf0, 0x03, 0x52, 0x01, 0x01, 0xdd, 0xaf, 0xce, 0xea,
    },
    {
        0x02, 0xb0, 0x15, 0x00, 0x02, 0xdf, 0x00, 0x00, 0xef, 0xfc, 0xf0, 0x00,
        0x03, 0xef, 0xfc, 0xf0, 0x03, 0x52, 0x01, 0x01, 0xd1, 0x85, 0x04, 0xa5,
    },
    {
        0x02, 0xb0, 0x15, 0x00, 0x01, 0xdf, 0x00, 0x00, 0xf0, 0x2d, 0xf0, 0x00,
        0x03, 0xf0, 0x2d, 0xf0, 0x03, 0x52, 0x01, 0x01, 0x88, 0x00, 0x20, 0x47,
    },
    {
        0x02, 0xb0, 0x15, 0x00, 0x18, 0xdf, 0x00, 0x00, 0xef, 0xfb, 0xf0, 0x00,
        0x03, 0xef, 0xfb, 0xf0, 0x03, 0x52, 0x01, 0x01, 0xa1, 0x72, 0xd8, 0xf4,
    },
    {
        0x02, 0xb0, 0x15, 0x00, 0x17, 0xdf, 0x00, 0x00, 0xf0, 0x02, 0xf0, 0x00,
        0x03, 0xf0, 0x02, 0xf0, 0x03, 0x52, 0x01, 0x01, 0x1c, 0xba, 0xf2, 0xf8,
    },
    {
        0x02, 0xb0, 0x15, 0x00, 0x13, 0xdf, 0x00, 0x00, 0xef, 0xfe, 0xf0, 0x00,
        0x03, 0xef, 0xfe, 0xf0, 0x03, 0x52, 0x01, 0x01, 0xcd, 0x03, 0x7b, 0xca,
    },
    {
        0x02, 0xb0, 0x15, 0x00, 0x12, 0xdf, 0x00, 0x00, 0xf0, 0x94, 0xf0, 0x00,
        0x03, 0xf0, 0x94, 0xf0, 0x03, 0x52, 0x01, 0x01, 0x79, 0xbc, 0xf7, 0x0a,
    },
    {
        0x02, 0xb0, 0x15, 0x00, 0x11, 0xdf, 0x00, 0x00, 0xf0, 0x92, 0xf0, 0x00,
        0x03, 0xf0, 0x92, 0xf0, 0x03, 0x52, 0x01, 0x01, 0x4f, 0xfd, 0x32, 0x5e,
    },
};

START_TEST(psi_tables)
{
    for (size_t i = 0; i < ASC_ARRAY_SIZE(test_tables); i++)
    {
        const uint8_t *const buf = test_tables[i];
        const size_t buf_size = buf[2] + 3;
        ck_assert(buf_size > CRC32_SIZE);

        const uint32_t expect = asc_get_be32(&buf[buf_size - CRC32_SIZE]);
        const uint32_t crc = au_crc32b(buf, buf_size - CRC32_SIZE);
        ck_assert(crc == expect);
    }
}
END_TEST

/* repeating patterns */
typedef struct
{
    const char *alphabet;
    size_t len;
    uint32_t crc[8];
} rep_test_t;

static
const rep_test_t rep_tests[] =
{
    {
        .alphabet = " ",

        .len = 16384,
        .crc = {
            0x57f69b40, 0x7d162c35, 0xea78abb0, 0x1023ba80,
            0x9a3faa96, 0xabebfa96, 0x9c7f8d03, 0x3c50b22d,
        },
    },
    {
        .alphabet = "0123456789",

        .len = 123,
        .crc = {
            0x6d3d8f7e, 0x26a4afab, 0xd8dd7ad0, 0xaaa26715,
            0x623b4455, 0x461e00c3, 0x05add70f, 0xe05e8ceb,
        },
    },
    {
        .alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",

        .len = 54321,
        .crc = {
            0x402ca6c7, 0x672fd0bf, 0x1815c7f5, 0x8f2ef75c,
            0xd487ce02, 0xcaa65445, 0x4ae18b5e, 0x43ab6519,
        },
    },
    {
        .alphabet = "abcdefghijklmnopqrstuvwxyz",

        .len = 9999,
        .crc = {
            0x3fcbe722, 0xf5ff86b5, 0x1cd6c120, 0x62cf1b77,
            0x61bf4344, 0x4d45f81f, 0xbc9e0fee, 0x7cf674e0,
        },
    },
    {
        .alphabet = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~",

        .len = 777,
        .crc = {
            0x46033477, 0xda7c3ff2, 0x4fe1a15f, 0x897a0c58,
            0x43f31cd5, 0x051fcc98, 0x9ddbe0da, 0xabc032f5,
        },
    },
    {
        .alphabet = "\xff\x01\x02\x03\x04\x05\x06\x07"
                    "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
                    "\x10\x11\x12\x13\x14\x15\x16\x17"
                    "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f",

        .len = 100000,
        .crc = {
            0x35f5c978, 0xbeb1e1c1, 0xa7ebaab6, 0x14f8ae62,
            0xe7f77085, 0x0e597077, 0x6ecc42cc, 0x30757d32,
        },
    },
};

START_TEST(repeating_strings)
{
    for (size_t j = 0; j < ASC_ARRAY_SIZE(rep_tests); j++)
    {
        const rep_test_t *const t = &rep_tests[j];
        const size_t alphachrs = strlen(t->alphabet);

        for (size_t r = 0; r < 8; r++)
        {
            const size_t len = (t->len * 8 * (r + 1)) + r;
            ck_assert(len % 8 == r);
            char *const buf = ASC_ALLOC(len, char);

            for (size_t i = 0; i < len; i++)
                buf[i] = t->alphabet[i % alphachrs];

            const uint32_t crc = au_crc32b(buf, len);
            ck_assert_msg(crc == t->crc[r]
                          , "rep: %zu/%zu/% 8zu: expected 0x%08x, got 0x%08x\n"
                          , j, r, len, t->crc[r], crc);

            free(buf);
        }
    }
}
END_TEST

/* zero length input */
START_TEST(zero_length)
{
    char empty[1] = { 0 };
    ck_assert(au_crc32b(NULL, 0) == 0);
    ck_assert(au_crc32b(empty, 0) == 0);
}
END_TEST

Suite *utils_crc32b(void)
{
    Suite *const s = suite_create("utils/crc32b");

    TCase *const tc = tcase_create("default");
    tcase_add_test(tc, psi_tables);
    tcase_add_test(tc, repeating_strings);
    tcase_add_test(tc, zero_length);
    suite_add_tcase(s, tc);

    return s;
}
